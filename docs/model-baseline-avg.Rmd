---
title: "Model: Baseline: Average per asset (m.corr: 0.00188)"
author: "Antony"
date: "2021-11-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r import}
suppressPackageStartupMessages({
  import(rpkgs)
})

import(run)
import(util)
```

Baseline model predict target = average value for the asset

# Model

```{r model}
modelName = "baseline-avg"

assets = getAllAssets()

runModel = \() {
  doRun(
    name = modelName,
    trnAmt = 60 * 24 * 7 * 1, # 1 week of data, chosen arbitrarily
    tstAmt = 60 * 24 * 7 * 2, # 2 weeks, submission period will provide new data every 2 weeks
    assets = assets[,asset_id],

    makeData = \(env, minDate, maxDate, assets, ...) {
      selectStmt = glue('
        SELECT ts, asset_id, asset_name, target
        FROM trn
        WHERE (ts BETWEEN $1 AND $2)
          AND asset_id IN ({paste(assets, collapse = ", ")})
      ')

      df = getQuery(selectStmt, params = list(minDate, maxDate))
      
      env$x = df[,.(ts, asset_id, asset_name)]
      env$y = df[,.(target)]
    },

    trainModel = \(model, trn, ...) {
      # give the model a description
      model$description = 'mean of target'

      model$getKeyForAsset = \(a) paste("asset-", a)
      for (a in unique(trn$x[,asset_id])) {
        idx = trn$x[,asset_id] == a
        key = model$getKeyForAsset(a)
        prediction = mean(trn$y[idx,target], na.rm = TRUE)
        if (is.na(prediction)) prediction = 0
        model[[key]] = prediction
      }
    },

    predictModel = \(model, tst, ...) {
      # use advanced machine learning algorithm to predict crypto movement
      tst$yhat = vector(mode = "numeric", length = nrow(tst$x))
      tst$yhat[1:length(tst$yhat)] <- NA
  
      for (a in unique(tst$x[,asset_id])) {
        idx = tst$x[,asset_id] == a
        key = model$getKeyForAsset(a)
        tst$yhat[idx] <- model[[key]]
      }
    }
  )
}
```

# Method

Same method as was used for the baseline "target = 0" model.

```{r method, results=FALSE, warning=FALSE, cache=TRUE}
numSamples = 610

set.seed(205794)

for (i in 1:numSamples) {
  results = runModel()
}
```

# Plots

We can examine the results from the last run, as a sanity-check.

```{r sanity, results=FALSE, cache=TRUE}
df = results$tst$x
df$y = results$tst$y$target
df$yhat = results$tst$yhat

set.seed(68420)

# sample of data
plotStart = sample(df[,ts], 1)
plotEnd = plotStart + as.difftime(200, units = "mins")

assets[sample(nrow(assets), 2),asset_name] |>
  lapply(\(asset) {
    df[asset_name == asset & ts > plotStart & ts < plotEnd] |>
      melt(id.vars = c("ts", "asset_name"), measure.vars = c("y", "yhat")) |>
      ggplot(aes(ts, value, colour = variable)) +
      geom_line() +
      facet_wrap(~asset_name, ncol = 1)
  }) |>
  print()
```

The competition metric is correlation between your predictions and the targets.

Visualising this:

```{r, echo=FALSE}
lastRunCorr = cor(df$yhat, df$y, use = "complete.obs")
p =
  ggplot(df, aes(yhat, y)) +
  geom_bin_2d() +
  labs(
    title = glue('yhat->y corr = {lastRunCorr}')
  )

ggplotly(p)
```

Remember, that's just for 1 run; we repeated that experiment `r numSamples` times!

# Evaluation {.tabset}

```{r}
scores = getQuery('SELECT * FROM metrics WHERE name = $1', params = list(modelName))
DT::datatable(scores[,.(run_id, corr, mae, aae, rmse)])
```

```{r}
performancePlot = \(x) {
  # https://stackoverflow.com/a/36344354

  count = sum(!is.na(x))
  mean = mean(x, na.rm = TRUE)
  sd = sd(x, na.rm = TRUE)
  sem = sd / sqrt(count)
  range = (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
  breaks = 30
  binwidth = range / breaks

  labelY = max(hist(x, breaks = breaks, plot = FALSE)$counts)

  makePlot = \(plotRange) {
    if (plotRange == "relative") {
      curveX = linspace(mean - range/2, mean + range/2, 100)
      labelX = mean + range/2
    } else if (plotRange == "absolute") {
      curveX = linspace(-0.05, 1.0, 1000)
      labelX = 1.0
    }

    annFmt = \(n) format(round(n, 5), nsmall=5)
    mcorrAnn = annotate(
      "text",
      label = glue('mean: {annFmt(mean)}\ns.err: {annFmt(sem)}\ns.dev: {annFmt(sd)}'),
      family = "monospace",
      hjust = "right",
      vjust = "top",
      x = labelX, y = labelY
    )

    curveY = dnorm(curveX, mean = mean, sd = sd) * binwidth * count
    curveD = data.table(
      corr = curveX,
      count = curveY
    )

    ggplot(data.frame(x = x), aes(x)) +
      xlab("corr") +
      ylab("count") +
      geom_histogram(binwidth = binwidth) +
      geom_line(data = curveD, aes(x = corr, y = count)) +
      geom_vline(xintercept = mean, color = "green") +
      geom_vline(xintercept = mean - 2.5*sem, color = "green", alpha = 0.5) +
      geom_vline(xintercept = mean + 2.5*sem, color = "green", alpha = 0.5) +
      geom_vline(xintercept = mean - 2.5*sd, color = "blue", alpha = 0.5) +
      geom_vline(xintercept = mean + 2.5*sd, color = "blue", alpha = 0.5) +
      mcorrAnn +
      labs(
        title = glue('Distribution of corr ({plotRange})')
      )
  }

  results = new.env(parent = .GlobalEnv)
  results$relativePlot = makePlot("relative")
  results$absolutePlot = makePlot("absolute")

  results$count = count
  results$mean = mean
  results$sd = sd
  results$sem = sem
  results$range = range
  results$binwidth = binwidth
  results$shapiro.test = shapiro.test(x)
  results$t.test = t.test(x)

  class(results) <- append(class(results), "performancePlot")
  results
}

format.performancePlot = \(p) {
  sw = paste(capture.output(print(p$shapiro.test)), collapse = "\n")
  tt = paste(capture.output(print(p$t.test)), collapse = "\n")
  glue('performancePlot:
       count = {p$count}
        mean = {p$mean}
          sd = {p$sd}
         sem = {p$sem}
       range = {p$range}
    binwidth = {p$binwidth}
relativePlot = <ggplot plot object>
absolutePlot = <ggplot plot object>
      t.test = {tt}')
}

print.performancePlot = \(p, ...) cat(format(p), ...)

p = performancePlot(scores[,corr])
print(p)
```

## Absolute range performance plot

```{r, echo=FALSE}
print(p$absolutePlot)
```

## Relative range performance plot

```{r, echo=FALSE}
print(p$relativePlot)
```

## Interactive plots

```{r, echo=FALSE}
ggplotly(p$absolutePlot)
ggplotly(p$relativePlot)
```

## Normality checks

```{r, echo=FALSE}
qqnorm(scores[,corr])
qqline(scores[,corr])
print(p$shapiro.test)
```
